#!/usr/bin/env python3
"""
Conduit Dispatch Generator

Parses Conduit applications and generates optimized dispatch code.

Usage:
    python tools/generate_dispatch.py examples/my_app.codon

This will:
1. Parse @app.get, @app.post, etc. decorators
2. Extract route information (method, path, handler name)
3. Generate optimal dispatch function
4. Write to my_app.dispatch.codon

Then include the dispatch file in your app:
    from my_app.dispatch import conduit_dispatch
"""

import re
import sys
from pathlib import Path
from typing import List, Tuple


class RouteInfo:
    """Information about a route"""
    def __init__(self, method: str, path: str, handler: str, line: int):
        self.method = method.upper()
        self.path = path
        self.handler = handler
        self.line = line
    
    def __repr__(self):
        return f"Route({self.method} {self.path} -> {self.handler})"


def parse_conduit_app(source_file: str) -> List[RouteInfo]:
    """
    Parse Conduit application source and extract routes
    
    Looks for patterns like:
        @app.get("/path")
        @app.post("/users/:id")
        def handler_name(request):
            ...
    """
    with open(source_file, 'r') as f:
        content = f.read()
    
    routes = []
    
    # Pattern: @app.METHOD("path")
    # Matches: @app.get("/"), @app.post("/users/:id"), etc.
    pattern = r'@app\.(get|post|put|delete|patch)\s*\(\s*"([^"]+)"\s*\)\s*\ndef\s+(\w+)\s*\('
    
    for match in re.finditer(pattern, content, re.MULTILINE):
        method = match.group(1)
        path = match.group(2)
        handler = match.group(3)
        
        # Calculate line number for debugging
        line = content[:match.start()].count('\n') + 1
        
        routes.append(RouteInfo(method, path, handler, line))
    
    return routes


def generate_dispatch_function(routes: List[RouteInfo]) -> str:
    """
    Generate optimized dispatch function
    
    Creates a function that takes (app, request, route_idx) and
    dispatches to the appropriate handler.
    """
    lines = [
        '"""',
        'Auto-generated dispatch code for Conduit',
        '',
        'DO NOT EDIT THIS FILE MANUALLY',
        'Generated by: tools/generate_dispatch.py',
        '"""',
        '',
        'def conduit_dispatch(app, request, route_idx: int):',
        '    """',
        '    Auto-generated dispatch function',
        '    ',
        f'    Handles {len(routes)} route(s)',
        '    """',
    ]
    
    if not routes:
        lines.extend([
            '    # No routes registered',
            '    return app.not_found_response()',
        ])
    else:
        for idx, route in enumerate(routes):
            # Add comment with route info
            if idx == 0:
                lines.append(f'    if route_idx == {idx}:  # {route.method} {route.path}')
            else:
                lines.append(f'    elif route_idx == {idx}:  # {route.method} {route.path}')
            
            lines.append(f'        return app.to_response({route.handler}(request))')
        
        # Default case - should never hit if routing is correct
        lines.extend([
            '    else:',
            '        return app.not_found_response()',
        ])
    
    return '\n'.join(lines)


def generate_dispatch_file(source_file: str, routes: List[RouteInfo]) -> str:
    """
    Generate complete dispatch file with imports and helper functions
    """
    # Parse source to check for imports we might need
    with open(source_file, 'r') as f:
        source_content = f.read()
    
    lines = [
        '"""',
        'Auto-generated dispatch code for Conduit',
        '',
        'Source: ' + Path(source_file).name,
        f'Routes: {len(routes)}',
        '',
        'DO NOT EDIT THIS FILE MANUALLY',
        'Generated by: tools/generate_dispatch.py',
        '',
        'To regenerate:',
        f'    python tools/generate_dispatch.py {source_file}',
        '"""',
        '',
    ]
    
    # Add dispatch function
    lines.append(generate_dispatch_function(routes))
    lines.append('')
    
    # Add route listing for debugging
    lines.extend([
        '',
        'def list_routes():',
        '    """List all registered routes"""',
        '    routes = [',
    ])
    
    for idx, route in enumerate(routes):
        lines.append(f'        ({idx}, "{route.method}", "{route.path}", "{route.handler}"),')
    
    lines.extend([
        '    ]',
        '    return routes',
        '',
    ])
    
    return '\n'.join(lines)


def main():
    """Main entry point"""
    if len(sys.argv) != 2:
        print("Usage: python tools/generate_dispatch.py <source_file.codon>")
        print()
        print("Example:")
        print("    python tools/generate_dispatch.py examples/my_app.codon")
        sys.exit(1)
    
    source_file = sys.argv[1]
    
    # Check file exists
    if not Path(source_file).exists():
        print(f"Error: File not found: {source_file}")
        sys.exit(1)
    
    # Check it's a .codon file
    if not source_file.endswith('.codon'):
        print(f"Error: Expected .codon file, got: {source_file}")
        sys.exit(1)
    
    print(f"üîç Parsing Conduit app: {source_file}")
    
    # Parse routes
    routes = parse_conduit_app(source_file)
    
    if not routes:
        print("‚ö†Ô∏è  Warning: No routes found")
        print("    Looking for @app.get, @app.post, etc. decorators")
    else:
        print(f"‚úÖ Found {len(routes)} route(s):")
        for route in routes:
            print(f"    Line {route.line:4d}: {route.method:6s} {route.path:30s} -> {route.handler}()")
    
    # Generate dispatch code
    print(f"\nüìù Generating dispatch code...")
    dispatch_code = generate_dispatch_file(source_file, routes)
    
    # Write output file
    output_file = source_file.replace('.codon', '.dispatch.codon')
    with open(output_file, 'w') as f:
        f.write(dispatch_code)
    
    print(f"‚úÖ Generated: {output_file}")
    print(f"üìä Size: {len(dispatch_code)} bytes")
    print()
    print("Next steps:")
    print(f"    1. Import in your app: from {Path(output_file).stem} import conduit_dispatch")
    print(f"    2. Use in server loop: response = conduit_dispatch(app, request, route_idx)")
    print(f"    3. Build: codon build {source_file}")
    print()
    print("‚ú® Automatic dispatch generated successfully!")


if __name__ == "__main__":
    main()
