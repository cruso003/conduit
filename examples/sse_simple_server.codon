from C import socket(int, int, int) -> int as c_socket
from C import bind(int, cobj, u32) -> int as c_bind
from C import listen(int, int) -> int as c_listen
from C import accept(int, cobj, cobj) -> int as c_accept
from C import recv(int, cobj, int, int) -> int as c_recv
from C import send(int, cobj, int, int) -> int as c_send
from C import close(int) -> int as c_close
from C import setsockopt(int, int, int, cobj, u32) -> int as c_setsockopt
from C import htons(u16) -> u16
from C import sleep(u32) -> u32

import time

AF_INET = 2
SOCK_STREAM = 1
SOL_SOCKET = 65535
SO_REUSEADDR = 4

class Socket:
    fd: int
    
    def __init__(self):
        self.fd = c_socket(AF_INET, SOCK_STREAM, 0)
    
    def bind(self, host: str, port: int):
        addr = Array[byte](16)
        port_be = int(htons(u16(port)))
        addr[0] = byte(16)
        addr[1] = byte(AF_INET)
        addr[2] = byte(port_be & 0xFF)
        addr[3] = byte((port_be >> 8) & 0xFF)
        for i in range(4, 16):
            addr[i] = byte(0)
        c_bind(self.fd, addr.ptr, u32(16))
    
    def listen(self, backlog: int):
        c_listen(self.fd, backlog)
    
    def set_reuseaddr(self):
        optval = Array[byte](4)
        optval[0] = byte(1)
        for i in range(1, 4):
            optval[i] = byte(0)
        c_setsockopt(self.fd, SOL_SOCKET, SO_REUSEADDR, optval.ptr, u32(4))
    
    def accept(self) -> Socket:
        addr = Array[byte](16)
        addrlen = Array[u32](1)
        addrlen[0] = u32(16)
        client_fd = c_accept(self.fd, addr.ptr, cobj(addrlen.ptr))
        client = Socket.__new__()
        client.fd = client_fd
        return client
    
    def recv(self, size: int) -> str:
        buffer = Array[byte](size)
        n = c_recv(self.fd, buffer.ptr, size, 0)
        if n <= 0:
            return ""
        return str(buffer.ptr, n)
    
    def send(self, data: str) -> int:
        return c_send(self.fd, data.ptr, len(data), 0)
    
    def close(self):
        if self.fd >= 0:
            c_close(self.fd)

# SSE classes inline for now
class SSEEvent:
    event: str
    data: str
    id: str
    retry: int
    
    def __init__(self, data: str, event: str = "", id: str = "", retry: int = 0):
        self.data = data
        self.event = event
        self.id = id
        self.retry = retry
    
    def format(self) -> str:
        lines = []
        if self.event:
            lines.append(f"event: {self.event}")
        if self.id:
            lines.append(f"id: {self.id}")
        if self.retry > 0:
            lines.append(f"retry: {self.retry}")
        for line in self.data.split("\n"):
            lines.append(f"data: {line}")
        return "\n".join(lines) + "\n\n"

print("=" * 70)
print("SSE Demo Server - Real-time Streaming")
print("=" * 70)
print("")
print("Starting server on http://localhost:8000")
print("")
print("Try these URLs:")
print("  http://localhost:8000/time   - Stream current time every second")
print("  http://localhost:8000/count  - Count from 1 to 10")
print("  http://localhost:8000/       - Home page")
print("")

sock = Socket()
sock.set_reuseaddr()
sock.bind("0.0.0.0", 8000)
sock.listen(5)

count = 0

while True:
    client = sock.accept()
    count += 1
    
    try:
        data = client.recv(4096)
        if not data:
            client.close()
            continue
        
        lines = data.split("\n")
        if len(lines) == 0:
            client.close()
            continue
        
        parts = lines[0].split(" ")
        if len(parts) < 2:
            client.close()
            continue
        
        path = parts[1]
        print(f"[{count}] {parts[0]} {path}")
        
        if path == "/time":
            # Stream time updates
            headers = "HTTP/1.1 200 OK\r\nContent-Type: text/event-stream\r\nCache-Control: no-cache\r\nConnection: keep-alive\r\nAccess-Control-Allow-Origin: *\r\n\r\n"
            client.send(headers)
            
            for i in range(10):
                evt = SSEEvent(f"Current time: {time.time()}", event="time", id=str(i+1))
                client.send(evt.format())
                sleep(u32(1))
            
            client.send("data: Stream complete\n\n")
        
        elif path == "/count":
            # Count from 1 to 10
            headers = "HTTP/1.1 200 OK\r\nContent-Type: text/event-stream\r\nCache-Control: no-cache\r\nConnection: keep-alive\r\nAccess-Control-Allow-Origin: *\r\n\r\n"
            client.send(headers)
            
            for i in range(1, 11):
                evt = SSEEvent(f"Count: {i}", event="counter", id=str(i))
                client.send(evt.format())
                sleep(u32(1))
        
        else:
            # Home page - serve the SSE client
            try:
                with open("examples/sse_client.html", "r") as f:
                    body = f.read()
                    response = "HTTP/1.1 200 OK\r\nContent-Type: text/html\r\nContent-Length: " + str(len(body)) + "\r\n\r\n" + body
            except:
                body = """<!DOCTYPE html>
<html>
<head><title>SSE Demo</title></head>
<body>
<h1>SSE Demo Server</h1>
<p><a href="/time">Stream Time</a></p>
<p><a href="/count">Stream Counter</a></p>
</body>
</html>"""
                response = "HTTP/1.1 200 OK\r\nContent-Type: text/html\r\nContent-Length: " + str(len(body)) + "\r\n\r\n" + body
            client.send(response)
    
    except Exception as e:
        print(f"[{count}] Error: {e}")
    
    finally:
        client.close()
