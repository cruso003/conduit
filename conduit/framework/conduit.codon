"""
Conduit Framework - Main API

The high-level framework class that provides decorator-based routing
and integrates all the low-level components.

Note: This framework integrates with the Conduit compiler plugin for
compile-time routing optimization. The plugin detects routes via
add_route_metadata() calls and generates an optimized dispatch function.

IMPORTANT: This framework REQUIRES compilation with the Conduit plugin:
    codon build -plugin conduit your_app.codon

The plugin generates the conduit_plugin_dispatch function at compile-time.
"""

from conduit.net.socket import Socket
from conduit.http.request import HTTPRequest, parse_http_request  
from conduit.http.response import HTTPResponse, not_found_json
from conduit.http.router import Router
from conduit.http.middleware import MiddlewareChain, LoggerMiddleware, CORSMiddleware, TimingMiddleware
from conduit.http.docs import APIDocGenerator, RouteDoc
from conduit.mcp.simple_http_client import SimpleAPITools

# Helper function for path parameter matching (called from plugin-generated code)
def match_path_pattern(path: str, pattern: str, params: Dict[str, str]) -> bool:
    """
    Match an incoming path against a route pattern with parameters.
    
    Args:
        path: Incoming request path (e.g., "/users/123")
        pattern: Route pattern (e.g., "/users/:id")
        params: Dictionary to populate with extracted parameters
    
    Returns:
        True if path matches pattern, False otherwise
    
    Example:
        params = {}
        if match_path_pattern("/users/123", "/users/:id", params):
            print(params["id"])  # "123"
    """
    # Split both path and pattern by '/'
    path_segments = path.split('/')[1:]  # Skip first empty segment
    pattern_segments = pattern.split('/')[1:]
    
    # Must have same number of segments
    if len(path_segments) != len(pattern_segments):
        return False
    
    # Match segment by segment
    for i in range(len(path_segments)):
        pattern_seg = pattern_segments[i]
        path_seg = path_segments[i]
        
        if pattern_seg.startswith(':'):
            # Parameter segment - extract value
            param_name = pattern_seg[1:]  # Remove ':' prefix
            params[param_name] = path_seg
        else:
            # Static segment - must match exactly
            if pattern_seg != path_seg:
                return False
    
    return True

# Default 404 handler - used by plugin when routes don't match
def _conduit_default_404(path: str = "") -> HTTPResponse:
    """Default 404 handler called by plugin-generated dispatch"""
    return not_found_json(path)

# Plugin replaces this stub's body at compile-time
def conduit_plugin_dispatch(method: str, path: str, request: HTTPRequest) -> HTTPResponse:
    # This body will be replaced by the plugin
    # If you see this message, the plugin didn't run!
    return HTTPResponse(500, "ERROR: Plugin did not generate dispatch function")

# Plugin metadata function - intercepted by compiler plugin
def conduit_dispatch_bucketed(method: str, path: str, request: HTTPRequest) -> HTTPResponse:
    """
    Dispatch function that routes requests to handlers
    
    This function calls the plugin-generated optimized dispatch.
    When compiled with -plugin conduit, routes to the plugin version.
    Without the plugin, returns an error.
    """
    return __plugin_dispatch_bucketed__(method, path, request)

# Plugin metadata function - intercepted by compiler plugin
def add_route_metadata(method: str, path: str, handler_name: str):
    """
    Route registration metadata for compiler plugin
    
    This function is called by decorators to register route metadata.
    The Conduit compiler plugin intercepts these calls during compilation
    to generate optimized dispatch code.
    
    Args:
        method: HTTP method (GET, POST, etc.)
        path: Route pattern (/users/:id)
        handler_name: Name of the handler function
    """
    # Empty implementation - plugin intercepts the IR call
    pass

class RouteInfo:
    """Information about a registered route"""
    pattern: str
    method: str
    name: str
    
    def __init__(self, pattern: str, method: str, name: str = ""):
        self.pattern = pattern
        self.method = method
        self.name = name

class MCPTool:
    """Information about a registered MCP tool"""
    name: str
    description: str
    handler_func: Optional[Callable]
    input_schema: Optional[dict]
    
    def __init__(self, name: str, description: str = "", handler_func: Optional[Callable] = None):
        self.name = name
        self.description = description  
        self.handler_func = handler_func
        self.input_schema = None

class MCPServer:
    """Integrated MCP server for the framework"""
    
    def __init__(self):
        """Initialize MCP server."""
        self.tools = []
        self.api_tools = SimpleAPITools()
        self.total_requests = 0
        self.total_token_savings = 0
    
    def register_tool(self, tool: MCPTool):
        """Register a new MCP tool."""
        self.tools.append(tool)
    
    def optimize_json(self, json_str: str) -> str:
        """Apply token optimization to JSON response."""
        optimized = json_str.replace(" ", "")
        optimized = optimized.replace('"jsonrpc":', '"j":')
        optimized = optimized.replace('"result":', '"r":')
        optimized = optimized.replace('"content":', '"c":')
        optimized = optimized.replace('"type":"text"', '"t":"txt"')
        optimized = optimized.replace('"text":', '"tx":')
        return optimized
    
    def handle_mcp_request(self, request_data: str) -> str:
        """Handle MCP JSON-RPC request."""
        self.total_requests += 1
        
        try:
            # Simple JSON-RPC parsing
            if '"method":"tools/list"' in request_data:
                return self._handle_list_tools(request_data)
            elif '"method":"tools/call"' in request_data:
                return self._handle_tool_call(request_data)
            elif '"method":"initialize"' in request_data:
                return self._handle_initialize(request_data)
            else:
                return '{"jsonrpc":"2.0","id":1,"error":{"code":-32601,"message":"Method not found"}}'
        
        except Exception as e:
            return '{"jsonrpc":"2.0","id":1,"error":{"code":-32000,"message":"Server error"}}'
    
    def _extract_id(self, request_data: str) -> int:
        """Extract request ID from JSON-RPC."""
        if '"id":' in request_data:
            start = request_data.find('"id":') + 5
            end = start
            while end < len(request_data) and request_data[end].isdigit():
                end += 1
            if end > start:
                return int(request_data[start:end])
        return 1
    
    def _handle_list_tools(self, request_data: str) -> str:
        """Handle tools/list request."""
        request_id = self._extract_id(request_data)
        
        # Build tools list
        tools_json = '{"tools":['
        
        for i, tool in enumerate(self.tools):
            if i > 0:
                tools_json += ','
            tools_json += '{"name":"' + tool.name + '","description":"' + tool.description + '"}'
        
        tools_json += ']}'
        
        response = '{"jsonrpc":"2.0","id":' + str(request_id) + ',"result":' + tools_json + '}'
        return self.optimize_json(response)
    
    def _handle_tool_call(self, request_data: str) -> str:
        """Handle tools/call request.""" 
        request_id = self._extract_id(request_data)
        
        # Extract tool name (simple string parsing)
        tool_name = ""
        if '"name":"' in request_data:
            start = request_data.find('"name":"') + 8
            end = request_data.find('"', start)
            if end > start:
                tool_name = request_data[start:end]
        
        # Find and execute tool
        for tool in self.tools:
            if tool.name == tool_name:
                try:
                    if tool.handler_func:
                        # Call the tool handler
                        result = tool.handler_func()  # Simplified - no args for now
                        response_json = '{"content":[{"type":"text","text":"' + str(result) + '"}]}'
                        response = '{"jsonrpc":"2.0","id":' + str(request_id) + ',"result":' + response_json + '}'
                        
                        # Apply token optimization
                        original_length = len(response)
                        optimized = self.optimize_json(response)
                        self.total_token_savings += (original_length - len(optimized))
                        
                        return optimized
                except Exception as e:
                    pass
        
        # Tool not found or error
        error_response = '{"jsonrpc":"2.0","id":' + str(request_id) + ',"error":{"code":-32000,"message":"Tool not found or error"}}'
        return self.optimize_json(error_response)
    
    def _handle_initialize(self, request_data: str) -> str:
        """Handle initialize request."""
        request_id = self._extract_id(request_data)
        init_response = '{"jsonrpc":"2.0","id":' + str(request_id) + ',"result":{"protocolVersion":"2024-11-05","serverInfo":{"name":"conduit-mcp","version":"1.0.0"}}}'
        return self.optimize_json(init_response)

class Conduit:
    """
    Main framework class for building web applications
    
    Example:
        app = Conduit()
        
        @app.get("/")
        def index(request):
            return {"message": "Hello, World!"}
        
        app.run()
    """
    
    host: str
    port: int
    router: Router
    route_info: List[RouteInfo]  # Metadata about routes
    middleware_chain: MiddlewareChain  # Middleware chain
    running: bool
    _dispatch_fn_set: bool  # Flag to track if dispatch is configured
    
    # Auto-documentation fields
    docs_enabled: bool
    doc_generator: APIDocGenerator
    api_title: str
    api_version: str
    
    def __init__(self, host: str = "0.0.0.0", port: int = 8000):
        """Initialize Conduit application"""
        self.host = host
        self.port = port
        self.router = Router()
        self.route_info = []
        self.middleware_chain = MiddlewareChain()
        self.running = False
        self._dispatch_fn_set = False
        self.docs_enabled = False
        self.api_title = "API"
        self.api_version = "1.0.0"
        # MCP integration
        self.mcp_server = None
        self.mcp_enabled = False
    
    def add_route_metadata(self, pattern: str, method: str, name: str = ""):
        """Register route metadata (called by decorators)"""
        # Register with runtime router for fallback
        self.router.add_route(pattern, method)
        self.route_info.append(RouteInfo(pattern, method, name))
    
    def get(self, pattern: str):
        """
        Decorator for GET routes
        
        Example:
            @app.get("/users")
            def get_users(request):
                return {"users": []}
        """
        def decorator(handler):
            # Call global metadata function (plugin intercepts this)
            add_route_metadata("GET", pattern, handler.__name__)
            
            # Register with runtime router
            self.add_route_metadata(pattern, "GET", handler.__name__)
            return handler
        return decorator
    
    def post(self, pattern: str):
        """Decorator for POST routes"""
        def decorator(handler):
            # Call global metadata function (plugin intercepts this)
            add_route_metadata("POST", pattern, handler.__name__)
            
            # Register with runtime router
            self.add_route_metadata(pattern, "POST", handler.__name__)
            return handler
        return decorator
    
    def put(self, pattern: str):
        """Decorator for PUT routes"""
        def decorator(handler):
            # Call global metadata function (plugin intercepts this)
            add_route_metadata("PUT", pattern, handler.__name__)
            
            # Register with runtime router
            self.add_route_metadata(pattern, "PUT", handler.__name__)
            return handler
        return decorator
    
    def delete(self, pattern: str):
        """Decorator for DELETE routes"""
        def decorator(handler):
            # Call global metadata function (plugin intercepts this)
            add_route_metadata("DELETE", pattern, handler.__name__)
            
            # Register with runtime router
            self.add_route_metadata(pattern, "DELETE", handler.__name__)
            return handler
        return decorator
    
    def patch(self, pattern: str):
        """Decorator for PATCH routes"""
        def decorator(handler):
            # Call global metadata function (plugin intercepts this)
            add_route_metadata("PATCH", pattern, handler.__name__)
            
            # Register with runtime router
            self.add_route_metadata(pattern, "PATCH", handler.__name__)
            return handler
        return decorator
    
    def use(self, middleware):
        """
        Register middleware to process requests/responses
        
        Example:
            from conduit.http.middleware_simple import logger_middleware, cors_middleware
            
            app.use(logger_middleware())
            app.use(cors_middleware("*"))
        """
        # Dispatch to appropriate add method based on type
        if isinstance(middleware, LoggerMiddleware):
            self.middleware_chain.add_logger(middleware)
        elif isinstance(middleware, CORSMiddleware):
            self.middleware_chain.add_cors(middleware)
        elif isinstance(middleware, TimingMiddleware):
            self.middleware_chain.add_timing(middleware)
    
    def enable_docs(self, title: str = "API Documentation", version: str = "1.0.0", 
                    description: str = "API built with Conduit"):
        """
        Enable auto-documentation with Swagger UI
        
        Serves interactive API docs at /docs and OpenAPI spec at /openapi.json
        
        Args:
            title: API title
            version: API version
            description: API description
            
        Example:
            app = Conduit()
            app.enable_docs(title="My API", version="2.0.0")
            app.run()
            # Visit http://localhost:8000/docs
        """
        self.docs_enabled = True
        self.api_title = title
        self.api_version = version
        self.doc_generator = APIDocGenerator(title, version)
        self.doc_generator.description = description
        
        print(f"ðŸ“š Auto-documentation enabled:")
        print(f"   Swagger UI: http://{self.host}:{self.port}/docs")
        print(f"   OpenAPI spec: http://{self.host}:{self.port}/openapi.json")
    
    def match_route(self, request: HTTPRequest):
        """
        Match a route and extract parameters
        
        Returns (matched: bool, route_idx: int, params: Dict[str, str])
        """
        matched, route_idx, params = self.router.match(request.path, request.method)
        
        if matched:
            request.params = params
        
        return (matched, route_idx, params)
    
    def print_dispatch_code(self):
        """
        Print dispatch boilerplate code for copy-paste
        
        Due to Codon's type system limitations, we cannot store arbitrary
        function pointers in collections. This helper generates the manual
        dispatch code you need to add to your server loop.
        
        Call this after registering all routes to see the code you need.
        """
        num_routes = len(self.route_info)
        
        print("")
        print("=" * 70)
        print(f"Dispatch Code for {num_routes} Routes")
        print("=" * 70)
        print("")
        print("Copy this into your server loop (after match_route):")
        print("")
        print("if matched:")
        
        for i in range(num_routes):
            route = self.route_info[i]
            if i == 0:
                print(f"    if route_idx == {i}:  # {route.method} {route.pattern}")
            else:
                print(f"    elif route_idx == {i}:  # {route.method} {route.pattern}")
            print(f"        response = app.to_response(handler_{i}(request))")
        
        print("    else:")
        print("        response = app.error_response(\"Unknown route index\")")
        print("else:")
        print("    response = app.not_found_response()")
        print("")
        print("=" * 70)
        print("")
        print("Handler mapping:")
        for i in range(num_routes):
            route = self.route_info[i]
            print(f"  handler_{i} = {route.name}  # {route.method} {route.pattern}")
        print("")
    
    def not_found_response(self) -> HTTPResponse:
        """Generate 404 response"""
        response = HTTPResponse(404, '{"error": "Route not found"}')
        response.set_content_type("application/json")
        return response
    
    def error_response(self, error_msg: str) -> HTTPResponse:
        """Generate 500 error response"""
        json_msg = '{"error": "' + error_msg + '"}'
        response = HTTPResponse(500, json_msg)
        response.set_content_type("application/json")
        return response
    
    def to_response(self, result) -> HTTPResponse:
        """
        Convert handler return value to HTTPResponse
        
        Supports:
        - HTTPResponse (pass through)
        - Dict (convert to JSON)
        - Tuple[Dict, int] (JSON with status code)
        - str (plain text)
        """
        # Already an HTTPResponse
        if isinstance(result, HTTPResponse):
            return result
        
        # Dict - convert to JSON
        if isinstance(result, dict):
            json_str = self._dict_to_json(result)
            response = HTTPResponse(200, json_str)
            response.set_content_type("application/json")
            return response
        
        # Tuple of (dict, status_code)
        if isinstance(result, tuple) and len(result) == 2:
            data, status = result
            if isinstance(data, dict):
                json_str = self._dict_to_json(data)
                response = HTTPResponse(status, json_str)
                response.set_content_type("application/json")
                return response
        
        # String - plain text
        if isinstance(result, str):
            response = HTTPResponse(200, result)
            response.set_content_type("text/plain")
            return response
        
        # Fallback - convert to string
        response = HTTPResponse(200, str(result))
        response.set_content_type("text/plain")
        return response
    
    def _dict_to_json(self, data: Dict) -> str:
        """
        Convert dict to JSON string
        
        Simple implementation - handle common cases
        """
        pairs = []
        for key in data:
            value = data[key]
            
            # Format value based on type
            if isinstance(value, str):
                value_str = '"' + value + '"'
            elif isinstance(value, int):
                value_str = str(value)
            elif isinstance(value, float):
                value_str = str(value)
            elif isinstance(value, bool):
                value_str = "true" if value else "false"
            elif isinstance(value, list):
                # Simple list handling
                value_str = self._list_to_json(value)
            elif isinstance(value, dict):
                # Nested dict
                value_str = self._dict_to_json(value)
            else:
                value_str = '"' + str(value) + '"'
            
            pair = '"' + key + '": ' + value_str
            pairs.append(pair)
        
        return '{' + ', '.join(pairs) + '}'
    
    def _list_to_json(self, items: List) -> str:
        """Convert list to JSON array string"""
        json_items = []
        for item in items:
            if isinstance(item, str):
                json_items.append('"' + item + '"')
            elif isinstance(item, dict):
                json_items.append(self._dict_to_json(item))
            else:
                json_items.append(str(item))
        
        return '[' + ', '.join(json_items) + ']'
    
    def handle_request(self, request: HTTPRequest) -> HTTPResponse:
        """
        Handle incoming HTTP request with middleware
        
        Routes the request to the appropriate handler and applies middleware.
        Middleware can modify responses (add headers, log, etc).
        
        Args:
            request: Parsed HTTP request
            
        Returns:
            HTTP response
        """
        # Check for MCP requests first
        if self.mcp_enabled and request.path == "/mcp" and request.method == "POST":
            # Handle MCP JSON-RPC request
            body = request.body if hasattr(request, 'body') else ""
            mcp_response = self.mcp_server.handle_mcp_request(body)
            
            # Create HTTP response
            response = HTTPResponse(200)
            response.body = mcp_response
            response.set_header("Content-Type", "application/json")
            response.set_header("Content-Length", str(len(mcp_response)))
            return response
        
        # Check for auto-docs routes
        if self.docs_enabled:
            if request.path == "/docs":
                return self.serve_docs()
            elif request.path == "/openapi.json":
                return self.serve_openapi_json()
        
        # Call plugin dispatch to get response
        try:
            response = conduit_plugin_dispatch(request.method, request.path, request)
        except:
            # Fallback for unmatched routes (404)
            response = not_found_json(request.path)
        
        # Apply middleware post-processing
        response = self.middleware_chain.execute_post_process(request, response)
        
        return response
    
    def serve_docs(self) -> HTTPResponse:
        """Serve Swagger UI HTML for interactive API documentation"""
        if not self.docs_enabled:
            return not_found_json("/docs")
        
        # Generate OpenAPI spec from registered routes
        self._populate_docs()
        
        # Get branded Swagger UI HTML
        html = self.doc_generator.generate_swagger_html()
        
        response = HTTPResponse(200)
        response.body = html
        response.set_header("Content-Type", "text/html; charset=utf-8")
        response.set_header("Content-Length", str(len(html)))
        return response
    
    def serve_openapi_json(self) -> HTTPResponse:
        """Serve OpenAPI 3.0 JSON specification"""
        if not self.docs_enabled:
            return not_found_json("/openapi.json")
        
        # Generate OpenAPI spec from registered routes
        self._populate_docs()
        
        # Get OpenAPI JSON
        spec_json = self.doc_generator.generate_openapi_json()
        
        response = HTTPResponse(200)
        response.body = spec_json
        response.set_header("Content-Type", "application/json")
        response.set_header("Content-Length", str(len(spec_json)))
        return response
    
    def _populate_docs(self):
        """Populate doc_generator with route information"""
        # Clear existing routes
        self.doc_generator.routes = []
        
        # Add documentation for each registered route
        for route_info in self.route_info:
            route_doc = RouteDoc(route_info.pattern, route_info.method)
            route_doc.set_summary(f"{route_info.method} {route_info.pattern}")
            
            # Use route name if available, otherwise generic description
            if route_info.name:
                route_doc.set_description(f"Handler: {route_info.name}")
            else:
                route_doc.set_description(f"Endpoint: {route_info.pattern}")
            
            # Extract path parameters
            if ":" in route_info.pattern:
                parts = route_info.pattern.split("/")
                for part in parts:
                    if part.startswith(":"):
                        param_name = part[1:]
                        route_doc.add_param(param_name, "string")
            
            self.doc_generator.add_route(route_doc)
    
    def _get_status_text(self, status: int) -> str:
        """Get status text for status code"""
        status_texts = {
            200: "OK",
            201: "Created",
            204: "No Content",
            400: "Bad Request",
            401: "Unauthorized",
            403: "Forbidden",
            404: "Not Found",
            500: "Internal Server Error",
            502: "Bad Gateway",
            503: "Service Unavailable"
        }
        
        if status in status_texts:
            return status_texts[status]
        return "Unknown"
    
    # MCP Integration Methods
    
    def enable_mcp(self, path: str = "/mcp"):
        """
        Enable MCP (Model Context Protocol) support
        
        Args:
            path: URL path for MCP endpoint (default: "/mcp")
        """
        if self.mcp_server is None:
            self.mcp_server = MCPServer()
        
        self.mcp_enabled = True
        
        # Register MCP endpoint
        def mcp_handler(request):
            if request.method == "POST":
                # Handle MCP JSON-RPC request
                body = request.body if hasattr(request, 'body') else ""
                return self.mcp_server.handle_mcp_request(body)
            else:
                return {"error": "MCP endpoint only accepts POST requests"}
        
        # Add MCP route
        self.add_route_metadata(path, "POST", "mcp_handler")
    
    def tool(self, name: str, description: str = ""):
        """
        Decorator to register a function as an MCP tool
        
        Args:
            name: Tool name for MCP protocol
            description: Tool description
            
        Example:
            @app.tool("get_weather", "Get current weather for a location")
            def weather_tool():
                return "Sunny, 72Â°F"
        """
        def decorator(handler):
            if self.mcp_server is None:
                self.mcp_server = MCPServer()
            
            # Create MCP tool
            tool = MCPTool(name, description, handler)
            self.mcp_server.register_tool(tool)
            
            return handler
        return decorator
    
    def get_mcp_stats(self) -> Dict:
        """
        Get MCP server statistics
        
        Returns:
            Dictionary with request count and token savings
        """
        if self.mcp_server is None:
            return {"requests": 0, "token_savings": 0, "tools": 0}
        
        return {
            "requests": self.mcp_server.total_requests,
            "token_savings": self.mcp_server.total_token_savings,
            "tools": len(self.mcp_server.tools)
        }

    def run(self, host: str = "", port: int = 0):
        """
        Start the application server
        
        Args:
            host: Override host (default: use constructor value)
            port: Override port (default: use constructor value)
        """
        # Use override or default
        if host:
            self.host = host
        if port > 0:
            self.port = port
        
        # Create socket
        sock = Socket()
        sock.bind(self.host, self.port)
        sock.listen(128)
        self.running = True
        
        print("")
        print("======================================================================")
        print("Conduit Framework")
        print("======================================================================")
        print("")
        print("Server running at http://" + self.host + ":" + str(self.port))
        print("")
        print("Registered routes:")
        # Skip route printing to avoid type error
        print("  " + str(len(self.router.routes)) + " route(s) registered")
        print("")
        print("Press Ctrl+C to stop")
        print("")
        
        # Accept loop
        while self.running:
            client = sock.accept()
            
            # Read request
            data = client.recv(4096)
            if len(data) == 0:
                client.close()
                continue
            
            # Parse HTTP request
            request = parse_http_request(data)
            
            # Handle request
            response = self.handle_request(request)
            
            # Send response
            response_str = response.to_bytes()
            client.send(response_str)
            client.close()
        
        sock.close()
        print("Server stopped.")
