"""
Conduit Framework - Main API

The high-level framework class that provides decorator-based routing
and integrates all the low-level components.

Note: This framework integrates with the Conduit compiler plugin for
compile-time routing optimization. The plugin detects routes via
add_route_metadata() calls and generates an optimized dispatch function.

IMPORTANT: This framework REQUIRES compilation with the Conduit plugin:
    codon build -plugin conduit your_app.codon

The plugin generates the conduit_plugin_dispatch function at compile-time.
"""

from conduit.net.socket import Socket
from conduit.http.request import HTTPRequest, parse_http_request  
from conduit.http.response import HTTPResponse
from conduit.http.router import Router

# Helper function for path parameter matching (called from plugin-generated code)
def match_path_pattern(path: str, pattern: str, params: Dict[str, str]) -> bool:
    """
    Match an incoming path against a route pattern with parameters.
    
    Args:
        path: Incoming request path (e.g., "/users/123")
        pattern: Route pattern (e.g., "/users/:id")
        params: Dictionary to populate with extracted parameters
    
    Returns:
        True if path matches pattern, False otherwise
    
    Example:
        params = {}
        if match_path_pattern("/users/123", "/users/:id", params):
            print(params["id"])  # "123"
    """
    # Split both path and pattern by '/'
    path_segments = path.split('/')[1:]  # Skip first empty segment
    pattern_segments = pattern.split('/')[1:]
    
    # Must have same number of segments
    if len(path_segments) != len(pattern_segments):
        return False
    
    # Match segment by segment
    for i in range(len(path_segments)):
        pattern_seg = pattern_segments[i]
        path_seg = path_segments[i]
        
        if pattern_seg.startswith(':'):
            # Parameter segment - extract value
            param_name = pattern_seg[1:]  # Remove ':' prefix
            params[param_name] = path_seg
        else:
            # Static segment - must match exactly
            if pattern_seg != path_seg:
                return False
    
    return True

# Plugin replaces this stub's body at compile-time
def conduit_plugin_dispatch(method: str, path: str, request: HTTPRequest) -> HTTPResponse:
    # This body will be replaced by the plugin
    # If you see this message, the plugin didn't run!
    return HTTPResponse(500, "ERROR: Plugin did not generate dispatch function")

# Plugin metadata function - intercepted by compiler plugin
def conduit_dispatch_bucketed(method: str, path: str, request: HTTPRequest) -> HTTPResponse:
    """
    Dispatch function that routes requests to handlers
    
    This function calls the plugin-generated optimized dispatch.
    When compiled with -plugin conduit, routes to the plugin version.
    Without the plugin, returns an error.
    """
    return __plugin_dispatch_bucketed__(method, path, request)

# Plugin metadata function - intercepted by compiler plugin
def add_route_metadata(method: str, path: str, handler_name: str):
    """
    Route registration metadata for compiler plugin
    
    This function is called by decorators to register route metadata.
    The Conduit compiler plugin intercepts these calls during compilation
    to generate optimized dispatch code.
    
    Args:
        method: HTTP method (GET, POST, etc.)
        path: Route pattern (/users/:id)
        handler_name: Name of the handler function
    """
    # Empty implementation - plugin intercepts the IR call
    pass

class RouteInfo:
    """Information about a registered route"""
    pattern: str
    method: str
    name: str
    
    def __init__(self, pattern: str, method: str, name: str = ""):
        self.pattern = pattern
        self.method = method
        self.name = name

class Conduit:
    """
    Main framework class for building web applications
    
    Example:
        app = Conduit()
        
        @app.get("/")
        def index(request):
            return {"message": "Hello, World!"}
        
        app.run()
    """
    
    host: str
    port: int
    router: Router
    route_info: List[RouteInfo]  # Metadata about routes
    running: bool
    _dispatch_fn_set: bool  # Flag to track if dispatch is configured
    
    def __init__(self, host: str = "0.0.0.0", port: int = 8000):
        """Initialize Conduit application"""
        self.host = host
        self.port = port
        self.router = Router()
        self.route_info = []
        self.running = False
        self._dispatch_fn_set = False
    
    def add_route_metadata(self, pattern: str, method: str, name: str = ""):
        """Register route metadata (called by decorators)"""
        # Register with runtime router for fallback
        self.router.add_route(pattern, method)
        self.route_info.append(RouteInfo(pattern, method, name))
    
    def get(self, pattern: str):
        """
        Decorator for GET routes
        
        Example:
            @app.get("/users")
            def get_users(request):
                return {"users": []}
        """
        def decorator(handler):
            # Call global metadata function (plugin intercepts this)
            add_route_metadata("GET", pattern, handler.__name__)
            
            # Register with runtime router
            self.add_route_metadata(pattern, "GET", handler.__name__)
            return handler
        return decorator
    
    def post(self, pattern: str):
        """Decorator for POST routes"""
        def decorator(handler):
            # Call global metadata function (plugin intercepts this)
            add_route_metadata("POST", pattern, handler.__name__)
            
            # Register with runtime router
            self.add_route_metadata(pattern, "POST", handler.__name__)
            return handler
        return decorator
    
    def put(self, pattern: str):
        """Decorator for PUT routes"""
        def decorator(handler):
            # Call global metadata function (plugin intercepts this)
            add_route_metadata("PUT", pattern, handler.__name__)
            
            # Register with runtime router
            self.add_route_metadata(pattern, "PUT", handler.__name__)
            return handler
        return decorator
    
    def delete(self, pattern: str):
        """Decorator for DELETE routes"""
        def decorator(handler):
            # Call global metadata function (plugin intercepts this)
            add_route_metadata("DELETE", pattern, handler.__name__)
            
            # Register with runtime router
            self.add_route_metadata(pattern, "DELETE", handler.__name__)
            return handler
        return decorator
    
    def patch(self, pattern: str):
        """Decorator for PATCH routes"""
        def decorator(handler):
            # Call global metadata function (plugin intercepts this)
            add_route_metadata("PATCH", pattern, handler.__name__)
            
            # Register with runtime router
            self.add_route_metadata(pattern, "PATCH", handler.__name__)
            return handler
        return decorator
    
    def match_route(self, request: HTTPRequest):
        """
        Match a route and extract parameters
        
        Returns (matched: bool, route_idx: int, params: Dict[str, str])
        """
        matched, route_idx, params = self.router.match(request.path, request.method)
        
        if matched:
            request.params = params
        
        return (matched, route_idx, params)
    
    def print_dispatch_code(self):
        """
        Print dispatch boilerplate code for copy-paste
        
        Due to Codon's type system limitations, we cannot store arbitrary
        function pointers in collections. This helper generates the manual
        dispatch code you need to add to your server loop.
        
        Call this after registering all routes to see the code you need.
        """
        num_routes = len(self.route_info)
        
        print("")
        print("=" * 70)
        print(f"Dispatch Code for {num_routes} Routes")
        print("=" * 70)
        print("")
        print("Copy this into your server loop (after match_route):")
        print("")
        print("if matched:")
        
        for i in range(num_routes):
            route = self.route_info[i]
            if i == 0:
                print(f"    if route_idx == {i}:  # {route.method} {route.pattern}")
            else:
                print(f"    elif route_idx == {i}:  # {route.method} {route.pattern}")
            print(f"        response = app.to_response(handler_{i}(request))")
        
        print("    else:")
        print("        response = app.error_response(\"Unknown route index\")")
        print("else:")
        print("    response = app.not_found_response()")
        print("")
        print("=" * 70)
        print("")
        print("Handler mapping:")
        for i in range(num_routes):
            route = self.route_info[i]
            print(f"  handler_{i} = {route.name}  # {route.method} {route.pattern}")
        print("")
    
    def not_found_response(self) -> HTTPResponse:
        """Generate 404 response"""
        response = HTTPResponse(404, '{"error": "Route not found"}')
        response.set_content_type("application/json")
        return response
    
    def error_response(self, error_msg: str) -> HTTPResponse:
        """Generate 500 error response"""
        json_msg = '{"error": "' + error_msg + '"}'
        response = HTTPResponse(500, json_msg)
        response.set_content_type("application/json")
        return response
    
    def to_response(self, result) -> HTTPResponse:
        """
        Convert handler return value to HTTPResponse
        
        Supports:
        - HTTPResponse (pass through)
        - Dict (convert to JSON)
        - Tuple[Dict, int] (JSON with status code)
        - str (plain text)
        """
        # Already an HTTPResponse
        if isinstance(result, HTTPResponse):
            return result
        
        # Dict - convert to JSON
        if isinstance(result, dict):
            json_str = self._dict_to_json(result)
            response = HTTPResponse(200, json_str)
            response.set_content_type("application/json")
            return response
        
        # Tuple of (dict, status_code)
        if isinstance(result, tuple) and len(result) == 2:
            data, status = result
            if isinstance(data, dict):
                json_str = self._dict_to_json(data)
                response = HTTPResponse(status, json_str)
                response.set_content_type("application/json")
                return response
        
        # String - plain text
        if isinstance(result, str):
            response = HTTPResponse(200, result)
            response.set_content_type("text/plain")
            return response
        
        # Fallback - convert to string
        response = HTTPResponse(200, str(result))
        response.set_content_type("text/plain")
        return response
    
    def _dict_to_json(self, data: Dict) -> str:
        """
        Convert dict to JSON string
        
        Simple implementation - handle common cases
        """
        pairs = []
        for key in data:
            value = data[key]
            
            # Format value based on type
            if isinstance(value, str):
                value_str = '"' + value + '"'
            elif isinstance(value, int):
                value_str = str(value)
            elif isinstance(value, float):
                value_str = str(value)
            elif isinstance(value, bool):
                value_str = "true" if value else "false"
            elif isinstance(value, list):
                # Simple list handling
                value_str = self._list_to_json(value)
            elif isinstance(value, dict):
                # Nested dict
                value_str = self._dict_to_json(value)
            else:
                value_str = '"' + str(value) + '"'
            
            pair = '"' + key + '": ' + value_str
            pairs.append(pair)
        
        return '{' + ', '.join(pairs) + '}'
    
    def _list_to_json(self, items: List) -> str:
        """Convert list to JSON array string"""
        json_items = []
        for item in items:
            if isinstance(item, str):
                json_items.append('"' + item + '"')
            elif isinstance(item, dict):
                json_items.append(self._dict_to_json(item))
            else:
                json_items.append(str(item))
        
        return '[' + ', '.join(json_items) + ']'
    
    def handle_request(self, request: HTTPRequest) -> HTTPResponse:
        """
        Handle incoming HTTP request
        
        Routes the request to the appropriate handler.
        Calls plugin-generated optimized dispatch function.
        
        Args:
            request: Parsed HTTP request
            
        Returns:
            HTTP response
        """
        # Phase 3: Call plugin-generated optimized dispatch
        # The plugin generates conduit_plugin_dispatch at compile time
        return conduit_plugin_dispatch(request.method, request.path, request)
    
    def _get_status_text(self, status: int) -> str:
        """Get status text for status code"""
        status_texts = {
            200: "OK",
            201: "Created",
            204: "No Content",
            400: "Bad Request",
            401: "Unauthorized",
            403: "Forbidden",
            404: "Not Found",
            500: "Internal Server Error",
            502: "Bad Gateway",
            503: "Service Unavailable"
        }
        
        if status in status_texts:
            return status_texts[status]
        return "Unknown"
    
    def run(self, host: str = "", port: int = 0):
        """
        Start the application server
        
        Args:
            host: Override host (default: use constructor value)
            port: Override port (default: use constructor value)
        """
        # Use override or default
        if host:
            self.host = host
        if port > 0:
            self.port = port
        
        # Create socket
        sock = Socket()
        sock.bind(self.host, self.port)
        sock.listen(128)
        self.running = True
        
        print("")
        print("======================================================================")
        print("Conduit Framework")
        print("======================================================================")
        print("")
        print("Server running at http://" + self.host + ":" + str(self.port))
        print("")
        print("Registered routes:")
        # Skip route printing to avoid type error
        print("  " + str(len(self.router.routes)) + " route(s) registered")
        print("")
        print("Press Ctrl+C to stop")
        print("")
        
        # Accept loop
        while self.running:
            client = sock.accept()
            
            # Read request
            data = client.recv(4096)
            if len(data) == 0:
                client.close()
                continue
            
            # Parse HTTP request
            request = parse_http_request(data)
            
            # Handle request
            response = self.handle_request(request)
            
            # Send response
            response_str = response.to_bytes()
            client.send(response_str)
            client.close()
        
        sock.close()
        print("Server stopped.")
