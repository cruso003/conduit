class HTTPRequest:
    method: str
    path: str
    query_string: str  # Raw query string
    headers: Dict[str, str]
    body: str
    params: Dict[str, str]  # Path parameters extracted by router
    query: Dict[str, str]   # Query parameters parsed from URL
    _json_cache: Dict[str, str]  # Cached parsed JSON body
    _json_parsed: bool
    
    def __init__(self):
        self.method = ""
        self.path = ""
        self.query_string = ""
        self.headers = {}
        self.body = ""
        self.params = {}
        self.query = {}
        self._json_cache = {}
        self._json_parsed = False
    
    def get_header(self, name: str, default: str = "") -> str:
        name_lower = name.lower()
        for key in self.headers:
            if key.lower() == name_lower:
                return self.headers[key]
        return default
    
    def parse_json(self) -> Dict[str, str]:
        """
        Parse JSON body and return as dict
        
        Note: Simple implementation for string-valued JSON objects only.
        Returns cached result on subsequent calls.
        """
        if self._json_parsed:
            return self._json_cache
        
        self._json_parsed = True
        
        if not self.body:
            return self._json_cache
        
        # Simple JSON parsing for {"key": "value", ...} format
        # Remove leading/trailing whitespace and braces
        json_str = self.body.strip()
        if not json_str.startswith("{") or not json_str.endswith("}"):
            return self._json_cache
        
        # Remove braces
        content = json_str[1:-1].strip()
        
        if not content:
            return self._json_cache
        
        # Split by commas (simple - doesn't handle nested objects)
        pairs = content.split(",")
        
        for pair in pairs:
            pair = pair.strip()
            if ":" not in pair:
                continue
            
            parts = pair.split(":", 1)
            key_part = parts[0].strip()
            value_part = parts[1].strip()
            
            # Remove quotes from key
            if key_part.startswith('"') and key_part.endswith('"'):
                key = key_part[1:-1]
            else:
                continue
            
            # Remove quotes from value
            if value_part.startswith('"') and value_part.endswith('"'):
                value = value_part[1:-1]
            else:
                # Handle non-string values as strings
                value = value_part
            
            self._json_cache[key] = value
        
        return self._json_cache

def parse_request_line(line: str):
    parts = line.strip().split(" ")
    
    if len(parts) != 3:
        raise ValueError(f"Invalid request line: '{line}'")
    
    method = parts[0].upper()
    path = parts[1]
    version = parts[2].upper()
    
    if not version.startswith("HTTP/"):
        raise ValueError(f"Invalid HTTP version: '{version}'")
    
    return (method, path, version)

def parse_headers(header_lines: List[str]) -> Dict[str, str]:
    headers: Dict[str, str] = {}
    
    for line in header_lines:
        line = line.strip()
        
        if not line:
            break
        
        if ":" in line:
            parts = line.split(":", 1)
            key = parts[0].strip()
            value = parts[1].strip()
            headers[key] = value
    
    return headers

def parse_http_request(data: str) -> HTTPRequest:
    request = HTTPRequest()
    
    if "\r\n\r\n" in data:
        parts = data.split("\r\n\r\n", 1)
        header_section = parts[0]
        request.body = parts[1] if len(parts) > 1 else ""
        line_sep = "\r\n"
    elif "\n\n" in data:
        parts = data.split("\n\n", 1)
        header_section = parts[0]
        request.body = parts[1] if len(parts) > 1 else ""
        line_sep = "\n"
    else:
        header_section = data
        line_sep = "\r\n" if "\r\n" in data else "\n"
    
    lines = header_section.split(line_sep)
    
    if len(lines) == 0:
        raise ValueError("Empty HTTP request")
    
    method, path, version = parse_request_line(lines[0])
    request.method = method
    
    # Split path and query string
    if "?" in path:
        path_parts = path.split("?", 1)
        request.path = path_parts[0]
        request.query_string = path_parts[1]
        request.query = parse_query_string(path_parts[1])
    else:
        request.path = path
        request.query_string = ""
    
    if len(lines) > 1:
        request.headers = parse_headers(lines[1:])
    
    return request

def parse_query_string(query: str) -> Dict[str, str]:
    """
    Parse URL query string into dict
    
    Example: "name=John&age=25" -> {"name": "John", "age": "25"}
    """
    params: Dict[str, str] = {}
    
    if not query:
        return params
    
    # Split by & to get key=value pairs
    pairs = query.split("&")
    
    for pair in pairs:
        if "=" not in pair:
            # Handle bare keys (key without value)
            params[pair] = ""
            continue
        
        parts = pair.split("=", 1)
        key = parts[0]
        value = parts[1] if len(parts) > 1 else ""
        
        # URL decode (simple - handles %20 for spaces)
        value = value.replace("%20", " ")
        value = value.replace("+", " ")
        
        params[key] = value
    
    return params
