"""
MCP Tool implementation with schema support and execution capabilities
"""

class ToolParameter:
    """Represents a tool parameter with type and description"""
    
    def __init__(self, name: str, param_type: str, description: str, required: bool = True):
        self.name = name
        self.param_type = param_type
        self.description = description
        self.required = required
    
    def to_json(self) -> str:
        """Convert parameter to JSON schema format"""
        json_str = '{'
        json_str += '"type":"' + self.param_type + '",'
        json_str += '"description":"' + self.description + '"'
        json_str += '}'
        return json_str


class Tool:
    """MCP Tool with schema validation and execution"""
    
    def __init__(self, name: str, description: str):
        self.name = name
        self.description = description
        self.parameters = dict[str, ToolParameter]()
        self._has_handler = False
    
    def add_parameter(self, name: str, param_type: str, description: str, required: bool = True):
        """Add a parameter to the tool schema"""
        param = ToolParameter(name, param_type, description, required)
        self.parameters[name] = param
    
    def set_handler(self):
        """Mark that the tool has a handler (simplified for Codon)"""
        self._has_handler = True
    
    def get_schema(self) -> str:
        """Generate JSON schema for the tool's input parameters"""
        schema = '{'
        schema += '"type":"object",'
        schema += '"properties":{'
        
        # Add parameter schemas
        prop_list = []
        for param_name, param in self.parameters.items():
            prop_entry = '"' + param_name + '":' + param.to_json()
            prop_list.append(prop_entry)
        
        schema += ",".join(prop_list)
        schema += '},'
        
        # Add required fields
        required_params = []
        for param_name, param in self.parameters.items():
            if param.required:
                required_params.append('"' + param_name + '"')
        
        if len(required_params) > 0:
            schema += '"required":[' + ",".join(required_params) + ']'
        else:
            schema += '"required":[]'
        
        schema += '}'
        return schema
    
    def execute(self, arguments: str) -> str:
        """Execute the tool with given arguments (simplified)"""
        if not self._has_handler:
            return "Error: No handler set for tool '" + self.name + "'"
        
        # Simplified execution - just return a demo response
        args = self._parse_arguments(arguments)
        return self._execute_tool(args)
    
    def _execute_tool(self, args: dict[str, str]) -> str:
        """Tool-specific execution logic (to be overridden)"""
        return "Tool executed with args: " + str(args)
    
    def _parse_arguments(self, arguments: str) -> dict[str, str]:
        """Parse JSON arguments into a dictionary (simplified)"""
        args = dict[str, str]()
        
        if arguments == "" or arguments == "{}":
            return args
        
        # Remove outer braces
        if arguments.startswith('{') and arguments.endswith('}'):
            content = arguments[1:-1]
        else:
            content = arguments
        
        # Split by commas (simplified - doesn't handle nested objects)
        pairs = content.split(',')
        
        for pair in pairs:
            if ':' in pair:
                key_value = pair.split(':', 1)
                if len(key_value) == 2:
                    key = key_value[0].strip().strip('"')
                    value = key_value[1].strip().strip('"')
                    args[key] = value
        
        return args
    
    def to_json(self) -> str:
        """Convert tool to MCP tool description format"""
        json_str = '{'
        json_str += '"name":"' + self.name + '",'
        json_str += '"description":"' + self.description + '",'
        json_str += '"inputSchema":' + self.get_schema()
        json_str += '}'
        return json_str


# Specialized tool classes
class WeatherTool(Tool):
    """Weather tool implementation"""
    
    def __init__(self):
        super().__init__("weather", "Get current weather for a city")
        self.add_parameter("city", "string", "The city to get weather for", True)
        self.set_handler()
    
    def _execute_tool(self, args: dict[str, str]) -> str:
        city = args.get("city", "Unknown")
        return "Weather in " + city + ": Sunny, 72Â°F (This is a demo response)"


class CalculatorTool(Tool):
    """Calculator tool implementation"""
    
    def __init__(self):
        super().__init__("calculate", "Perform basic mathematical calculations")
        self.add_parameter("expression", "string", "Mathematical expression to evaluate", True)
        self.set_handler()
    
    def _execute_tool(self, args: dict[str, str]) -> str:
        expression = args.get("expression", "")
        # Simplified calculator - would use proper math parser in real implementation
        try:
            # Basic safety check
            if any(char in expression for char in "abcdefghijklmnopqrstuvwxyz"):
                return "Error: Only numbers and basic operators (+, -, *, /) allowed"
            
            # Simple evaluation (unsafe - for demo only)
            result = str(eval(expression))
            return "Result: " + result
        except:
            return "Error: Invalid expression '" + expression + "'"


# Helper function to create a simple tool
def create_tool(name: str, description: str) -> Tool:
    """Create a new tool with name and description"""
    tool = Tool(name, description)
    return tool


# Example tool factory functions
def create_weather_tool() -> WeatherTool:
    """Create a sample weather tool"""
    return WeatherTool()


def create_calculator_tool() -> CalculatorTool:
    """Create a sample calculator tool"""
    return CalculatorTool()