#!/usr/bin/env python3
"""
Generate Codon test files with varying numbers of routes for benchmarking.

This script creates test files with different route counts to measure
dispatch performance scaling characteristics.
"""

import sys
from pathlib import Path


def generate_route_file(num_routes: int, output_path: Path) -> None:
    """Generate a Codon file with the specified number of routes."""
    
    methods = ["GET", "POST", "PUT", "DELETE", "PATCH"]
    method_names = {
        "GET": "get",
        "POST": "post",
        "PUT": "put",
        "DELETE": "delete",
        "PATCH": "patch"
    }
    
    # File header - standalone test file matching test_plugin_minimal.codon pattern
    content = [
        "# Auto-generated benchmark test file",
        f"# Routes: {num_routes}",
        "# Generated by: benchmarks/generate_test_routes.py",
        "",
        "# Simulate the metadata function the plugin looks for",
        "def add_route_metadata(pattern: str, method: str, handler_name: str):",
        "    pass",
        "",
        "# Minimal app class with decorators",
        "class App:",
    ]
    
    # Generate decorator methods for each HTTP method
    for method in methods:
        method_lower = method.lower()
        content.extend([
            f"    def {method_lower}(self, pattern: str):",
            f"        def decorator(handler):",
            f"            add_route_metadata(pattern, \"{method}\", handler.__name__)",
            f"            return handler",
            f"        return decorator",
            f"    ",
        ])
    
    content.extend([
        "app = App()",
        "",
    ])
    
    # Generate routes
    for i in range(num_routes):
        method = methods[i % len(methods)]
        
        # Create diverse route patterns
        if i % 5 == 0:
            # Simple static route
            path = f"/route_{i}"
        elif i % 5 == 1:
            # Single parameter
            path = f"/users/:id_{i}"
        elif i % 5 == 2:
            # Nested path
            path = f"/api/v1/resource_{i}"
        elif i % 5 == 3:
            # Multiple segments with param
            path = f"/api/users/:id/items_{i}"
        else:
            # Deep nesting
            path = f"/api/v2/category_{i}/:id/details"
        
        # Generate handler function
        content.extend([
            f"@app.{method.lower()}(\"{path}\")",
            f"def handler_{i}(req: str) -> str:",
            f"    return \"Response from handler {i}\"",
            "",
        ])
    
    # Add a simple main to make it compilable
    content.extend([
        "# Test compilation",
        "if __name__ == \"__main__\":",
        "    print(\"Test file compiled successfully\")",
        f"    print(\"Total routes: {num_routes}\")",
    ])
    
    # Write to file
    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text("\n".join(content))
    
    print(f"âœ… Generated {output_path} with {num_routes} routes")


def main():
    """Generate test files for different route counts."""
    
    # Define route counts to test
    route_counts = [10, 50, 100, 200, 500]
    
    if len(sys.argv) > 1:
        # Use custom route counts if provided
        route_counts = [int(x) for x in sys.argv[1:]]
    
    # Output directory
    output_dir = Path(__file__).parent / "test_files"
    
    print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    print("â•‘  ğŸ“Š Benchmark Test File Generator                       â•‘")
    print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    print()
    
    for count in route_counts:
        output_file = output_dir / f"test_routes_{count}.codon"
        generate_route_file(count, output_file)
    
    print()
    print(f"âœ… Generated {len(route_counts)} test files in {output_dir}")
    print()
    print("Next steps:")
    print("  1. Compile each test file with the Conduit plugin")
    print("  2. Measure compilation time and generated code size")
    print("  3. Run performance benchmarks")


if __name__ == "__main__":
    main()
